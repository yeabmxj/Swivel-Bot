#pragma config(Sensor, in1,    leftTapeFinder, sensorLineFollower)
#pragma config(Sensor, in2,    rightTapeFinder, sensorLineFollower)
#pragma config(Sensor, in3,    distanceFinder, sensorAnalog)
#pragma config(Sensor, dgtl1,  frontProximitySensor, sensorSONAR_cm)
#pragma config(Sensor, dgtl3,  rightProximitySensor, sensorSONAR_cm)
#pragma config(Sensor, dgtl5,  bottomRightProximitySensor, sensorSONAR_cm)
#pragma config(Motor,  port2,           swivelWheel,   tmotorVex269_MC29, openLoop)
#pragma config(Motor,  port3,           leftWheel,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           rightWheel,    tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//RobotAttribs.
int StartUpTimeMsec = 5000;
int run = 0;
bool completed = false;
int wheelRadius = 1;
bool simpleRun = true;

//PinMovement
int minTapeValue = 1000;
int circleCount = 0;
int totalNumberOfCircles = 3;
int turnTimeMsec = 1500;

//Speeds
int steadySpeed = 30;
int fasterSpeed = 60;

//SONAR
int minDistanceToObstacle = 10;		//cm

//Tasks
int task_1_Duration = 12500;
int task_2_Duration = 5000;
int task_3_Duration = 5000;


void pinManuver(int speed) {
	if (SensorValue(leftTapeFinder) < minTapeValue && SensorValue(rightTapeFinder) < minTapeValue) {
		motor[swivelWheel] = 0;
		motor[leftWheel] = speed;
		motor[rightWheel] = speed;
	}
	else if (SensorValue(leftTapeFinder) >= minTapeValue && SensorValue(rightTapeFinder) < minTapeValue) {
		motor[swivelWheel] = 180;
		motor[leftWheel] = 0;
		motor[rightWheel] = speed;
	}
	else if (SensorValue(leftTapeFinder) < minTapeValue && SensorValue(rightTapeFinder) >= minTapeValue) {
		motor[swivelWheel] = 180;
		motor[leftWheel] = speed;
		motor[rightWheel] = 0;
	}
	else if (SensorValue(leftTapeFinder) >= minTapeValue && SensorValue(rightTapeFinder) >= minTapeValue) {
		motor[swivelWheel] = 180;
		motor[leftWheel] = speed;
		motor[rightWheel] = speed;
		circleCount += 1;
	}
}

void pinTurn(int timeInMsec, int direction) {
	motor[swivelWheel] = 90;
	motor[leftWheel] = 0;
	motor[rightWheel] = direction * steadySpeed;
	wait1Msec(timeInMsec);
	motor[swivelWheel] = 0;
	motor[leftWheel] = 0;
	motor[rightWheel] = 0;
}

void task_1() {
	switch (run) {
	case 0:
		pinManuver(steadySpeed);
		if (circleCount == totalNumberOfCircles) {
			run += 1;
		}
		break;
	case 1:
		motor[swivelWheel] = 0;
		motor[leftWheel] = 0;
		motor[rightWheel] = 0;
		run = 0;
		completed = true;
		break;
	}
}
void task_2() {
	switch (run) {
	case 0:
		motor[leftWheel] = steadySpeed;
		motor[rightWheel] = steadySpeed;
		if (circleCount != 0 && circleCount != totalNumberOfCircles) {
			run += 1;
		}
		break;
	case 1:
		pinManuver(steadySpeed);
		if (circleCount == totalNumberOfCircles) {
			run += 1;
		}
		break;
	case 2:
		motor[swivelWheel] = 0;
		motor[leftWheel] = 0;
		motor[rightWheel] = 0;
		wait1Msec(5000);
		run += 1;
		break;
	case 3:
		pinTurn(turnTimeMsec, 1);
		circleCount = 0;
		run += 1;
		break;
	case 4:
		motor[leftWheel] = steadySpeed;
		motor[rightWheel] = steadySpeed;
		wait1Msec(3000);
		run += 1;
		break;
	case 5:
		pinManuver(steadySpeed);
		if (circleCount == totalNumberOfCircles) {
			run += 1;
		}
		break;
	case 6:
		motor[swivelWheel] = 0;
		motor[leftWheel] = 0;
		motor[rightWheel] = 0;
		run = 0;
		completed = true;
		break;
	}
}
void task_3() {

	int startValue = 0;
	int endValue = 0;

	switch(run) {
	case 0:
		motor[swivelWheel] = 0;
		motor[leftWheel] = steadySpeed;
		motor[rightWheel] = steadySpeed;
		if (SensorValue[frontProximitySensor] < minDistanceToObstacle) {
			motor[swivelWheel] = 0;
			motor[leftWheel] = 0;
			motor[rightWheel] = 0;
			run += 1;
		}
		break;
	case 1:
		pinTurn(turnTimeMsec, 1);
		startValue = SensorValue[distanceFinder];
		run += 1;
		break;
	case 2:
		motor[swivelWheel] = 0;
		motor[leftWheel] = steadySpeed;
		motor[rightWheel] = steadySpeed;
		if (SensorValue[bottomRightProximitySensor] > minDistanceToObstacle) {
			motor[swivelWheel] = 0;
			motor[leftWheel] = 0;
			motor[rightWheel] = 0;
			endValue = SensorValue[distanceFinder];
			run += 1;
		}
		break;
	case 3:
		pinTurn(turnTimeMsec, -1);
		run += 1;
		break;
	case 4:
		motor[swivelWheel] = 0;
		motor[leftWheel] = steadySpeed;
		motor[rightWheel] = steadySpeed;
		if (SensorValue[bottomRightProximitySensor] > minDistanceToObstacle) {
			motor[swivelWheel] = 0;
			motor[leftWheel] = 0;
			motor[rightWheel] = 0;
			run += 1;
		}
		break;
	case 5:
		pinTurn(turnTimeMsec, -1);
		run += 1;
		break;
	}
}

void simple_task_1() {
	motor[leftWheel] = fasterSpeed;
	motor[rightWheel] = fasterSpeed;
	motor[swivelWheel] = 0;
	wait1Msec(task_1_Duration);

	motor[leftWheel] = 0;
	motor[rightWheel] = 0;
	motor[swivelWheel] = 0;
	simpleRun = false;
}

void simple_task_2() {
	motor[leftWheel] = fasterSpeed;
	motor[rightWheel] = fasterSpeed;
	motor[swivelWheel] = 0;
	wait1Msec(task_2_Duration);

	motor[leftWheel] = 0;
	motor[rightWheel] = 0;
	motor[swivelWheel] = 0;
	wait1Msec(task_2_Duration);

	pinTurn(1, turnTimeMsec);

	motor[leftWheel] = fasterSpeed;
	motor[rightWheel] = fasterSpeed;
	motor[swivelWheel] = 0;
	wait1Msec(task_2_Duration);

	motor[leftWheel] = 0;
	motor[rightWheel] = 0;
	motor[swivelWheel] = 0;
}

void simple_task_3() {
	motor[leftWheel] = fasterSpeed;
	motor[rightWheel] = fasterSpeed;
	motor[swivelWheel] = 0;
	wait1Msec(task_3_Duration);

	motor[leftWheel] = 0;
	motor[rightWheel] = 0;
	motor[swivelWheel] = 0;
	wait1Msec(task_3_Duration);

	pinTurn(1, turnTimeMsec);

	motor[leftWheel] = fasterSpeed;
	motor[rightWheel] = fasterSpeed;
	motor[swivelWheel] = 0;
	wait1Msec(task_3_Duration);

	motor[leftWheel] = 0;
	motor[rightWheel] = 0;
	motor[swivelWheel] = 0;
	wait1Msec(task_3_Duration);

	pinTurn(-1, turnTimeMsec);

	motor[leftWheel] = fasterSpeed;
	motor[rightWheel] = fasterSpeed;
	motor[swivelWheel] = 0;
	wait1Msec(task_3_Duration);

	motor[leftWheel] = 0;
	motor[rightWheel] = 0;
	motor[swivelWheel] = 0;
	wait1Msec(task_3_Duration);

	pinTurn(-1, turnTimeMsec);

	motor[leftWheel] = fasterSpeed;
	motor[rightWheel] = fasterSpeed;
	motor[swivelWheel] = 0;
	wait1Msec(task_3_Duration);

	motor[leftWheel] = 0;
	motor[rightWheel] = 0;
	motor[swivelWheel] = 0;
	wait1Msec(task_3_Duration);

	pinTurn(1, turnTimeMsec);

	motor[leftWheel] = fasterSpeed;
	motor[rightWheel] = fasterSpeed;
	motor[swivelWheel] = 0;
	wait1Msec(task_3_Duration);

	motor[leftWheel] = 0;
	motor[rightWheel] = 0;
	motor[swivelWheel] = 0;
	wait1Msec(task_3_Duration);
}

int distanceTraveled() {
	return (distanceFinder / 360) * (2 * 3.14 * wheelRadius);
}

task main() {


	wait1Msec(StartUpTimeMsec);

	while(simpleRun) {
		writeDebugStream("Int i is : %d", SensorValue[leftTapeFinder]);
		writeDebugStream("Int i is : %d", SensorValue[rightTapeFinder]);

		simple_task_1();
		//simple_task_2();
		//simple_task_3();
	}
	/*
	while (!simpleRun) {

	do {task_1();}
	while (!completed);

	completed = false;

	do {task_2();}
	while (!completed);

	completed = false;

	do {task_3();}
	while (!completed);
	}
	*/
}
